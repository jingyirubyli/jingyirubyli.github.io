---
layout: post
title:  DCN Lec8-Programmable Data Plane
date:   2025-03-06
description: You’ll find this post in your `_posts` directory. Go ahead and edit it and re-build the site to see your changes. # Add post description (optional)
img: post-8.png # Add image post (optional)
tags: [Blog, DCN]
author: # Add name author (optional)
---
# 本讲内容

## 传统高速交换机

### Fixed function switch
传统高速（100s of Gbps to multi-Tbps）交换机是“fixed-function”:
- 即，交换芯片硬连线以执行一组特定的功能（例如 IP 转发）
- 不可编程Not programmable：无法修改以实施新协议
- 为了性能而牺牲了可编程性: 正如传统观点所说，很难同时实现两者.

<figure style="text-align: center;">
  <img src="/assets/img/l8p1.png" alt="Packet processing pipeline" width="600">
  <figcaption>Packet processing pipeline on fixed function switch</figcaption>
</figure>

上图展示了一个典型的数据包处理流水线（pipeline），涉及从数据包进入（Packet In）到数据包输出（Packet Out）的整个处理流程。下面详细解析各个组件的功能：

1. 数据包输入（Packet In）
   - 数据包从外部网络接口进入处理管道。
2. 解析器（Parser）
    - 解析器提取数据包的头部字段（Header fields）,如以太网头、IP头等, 提取关键信息（如源/目的MAC地址、IP地址、协议类型等）, 和有效载荷（Payload）。
    - 头部字段（如 MAC 地址、IP 地址等）被送入后续处理阶段，而有效载荷保持不变。    
3. 处理阶段 (Stages)
    处理过程由多个阶段组成：
    - L2 Stage（第二层处理阶段）/L2表查询
       - 主要进行以太网（Ethernet）层的处理，例如 MAC 地址学习、VLAN 处理等。
       - **表结构: L2: 128k x 48（128k条目，每条48位）。**
       - **匹配方式: 精确匹配（Exact Match），基于目的MAC地址。**
       - **动作：set L2D（设置第二层目标地址，如转发端口的MAC地址）。**

        <figure style="text-align: center;">
        <img src="/assets/img/l8p2.png" alt="L2 Stage" width="600">
        <figcaption>L2 Stage</figcaption>
        </figure>

    - L3 Stage（第三层处理阶段）/L3表查询
       - 主要进行 IP 层处理，如路由查找、TTL 递减、NAT（网络地址转换）等。
       - **表结构：L3: 16k x 32（16k条目，每条32位）。**
       - **匹配方式：最长前缀匹配（Longest Prefix Match），基于目的IP地址。**
       - **动作：**
          - **set L3D：设置第三层目标地址（如下一跳IP地址）。**
          - **dec TTL：减少IP头部生存时间（TTL），防止数据包无限循环。**

        <figure style="text-align: center;">
        <img src="/assets/img/l8p3.png" alt="L3 Stage" width="600">
        <figcaption>L3 Stage</figcaption>
        </figure>

    - ACL Stage（访问控制列表阶段）
      - 负责基于预定义的安全策略进行数据包过滤，决定数据包是否被允许通过或丢弃。
      - **表结构：ACL: 4k（4k条目）。**
      - **匹配方式：三元匹配（Ternary Match），支持通配符（如匹配源/目的IP、端口范围等）。**
      - **动作：**
        - **permit：允许数据包通过。**
        - **deny：丢弃数据包（如安全策略不允许的流量）。**

        <figure style="text-align: center;">
        <img src="/assets/img/l8p4.png" alt="ACL Stage" width="600">
        <figcaption>ACL Stage</figcaption>
        </figure>

    |  组件  | 表类型    | 匹配方式            | 动作                         |
    |:------:|-----------|---------------------|------------------------------|
    | L2 表  | 128k x 48 | 精确匹配（Exact）   | 设置目标MAC地址（set L2D）   |
    | L3 表  | 16k x 32  | 最长前缀匹配（LPM） | 设置目标IP地址、减少TTL      |
    | ACL 表 | 4k        | 三元匹配（Ternary） | 允许（permit）或拒绝（deny） |

    这些阶段通过并行流水线方式传递处理结果，提高处理速度。

4. 反解析器（Deparser）
    - 在所有处理完成后，根据处理结果重新组装数据包头部（如更新TTL、MAC地址等），生成最终输出的数据包格式。
5. 队列（Queues）
    - 数据包经过处理后，将处理后的数据包按优先级或流量类别放入不同队列，进行流量整形或调度（如保证高优先级流量优先转发）。
6. 数据包输出（Packet Out）
    - 经过所有处理后，数据包被转发到合适的端口，从队列中取出，通过指定物理端口发送到外部网络, 完成整个处理过程。

这张图描述了一个典型的数据包处理流水线，依次经过解析、L2 处理、L3 处理、ACL 处理，最终重新封装并输出数据包。该结构常见于软件定义网络（SDN）交换机或高性能网络设备中，优化数据包转发效率，同时提供灵活的网络管理能力。

但是……如果您需要灵活性怎么办？所谓灵活性flexibility包括：
- 添加新表
- 添加新标题字段
- 添加不同操作

SDN 强调对灵活性的需求
- SDN 为控制平面control plane提供编程控制
- 要完全实现 SDN 的愿景, 我们需要在数据平面data plane中拥有同样的灵活性！

### 现有的解决方案

- Software？比fixed-function ASIC switches慢 100 倍
- NPUs？比fixed-function ASIC switches慢 10 倍
- FPGAs？比fixed-function ASIC switches慢 10 倍

> An ASIC switch is a switch that uses an application-specific integrated circuit (ASIC) chip. ASICs are custom-made chips that are designed to perform specific functions. 
> ASIC 交换机是一种使用专用集成电路 (ASIC) 芯片的交换机。ASIC 是专门为执行特定功能而设计的定制芯片。

我们需要一个Programmable Switch ASIC！

## RMT(Reconfigurable Match Table) Design 可重构匹配表

RMT（Reconfigurable Match Table，可重构匹配表） 是一种灵活的网络数据包处理架构，核心特点如下：

1. Reconfigurable 可自定义
   - parse custom header fields 解析自定义：支持用户定义数据包的头部字段解析规则（如协议类型、字段结构）。
   - create custom match tables 匹配表自定义：允许用户创建专用匹配表（如路由表、ACL表）
   - take custom actions 动作自定义: 指定每条表项的匹配条件与对应动作（如转发、丢弃、修改字段）。
2. Two key abstractions 两个关键抽象模型:
   - Parse Graph 解析图: 定义数据包头部字段的解析流程，逐层提取所需信息（如以太网头→IP头→TCP头）。
   - Table Graph 表图: 描述匹配表之间的逻辑关系与动作执行顺序（如先查L2表→再查L3表→最后执行ACL过滤）。
3. Can be programmed using a domain-specific language called P4
   - 通过领域专用语言P4 (Programming Protocol-Independent Packet Processors) 实现编程。
   - 声明式特性：用户只需声明“要做什么”（如解析哪些字段、如何匹配和动作），无需关注底层硬件实现细节。

### 解析图（Parse Graph）

解析图（Parse Graph）是RMT（可重构匹配表）模型中的一个核心抽象，用于定义数据包头部字段的解析流程。它决定了数据包从进入系统开始，如何逐层提取和处理不同协议层的头部信息。

1. 解析图的基本定义

- 功能定位：解析图位于数据包处理流程的最前端，负责将原始数据包的二进制流转换为结构化、可操作的头部字段信息。
- 核心任务：根据用户定义的规则，识别并提取数据包中各协议层的头部（如以太网头、IP头、TCP头等），为后续的匹配和动作执行提供输入。

2. 解析图的组成元素

解析图通常由以下要素构成：

- 节点（Nodes）：每个节点代表一个协议层（如以太网、IPv4、TCP）或自定义头部字段（如VXLAN、MPLS）。
- 边（Edges）：边表示解析的顺序和依赖关系，例如必须先解析以太网头才能确定下一层是否为IP头。
- 解析逻辑（Parsing Logic）：每个节点包含具体的解析规则，例如字段长度、偏移量、数据类型（如16位整数、字符串）等。

3. 用户自定义解析规则

通过P4语言，用户可以灵活定义解析图的结构和逻辑：

- 协议无关性：支持任意自定义协议，无需依赖硬件预定义的协议栈。例如，可以解析传统协议（如IPv6）或私有协议（如物联网设备专用头部）。
- 动态字段提取：根据数据包内容动态判断下一层协议类型。例如：
  - 解析以太网头后，根据EtherType字段（如0x0800代表IPv4，0x86DD代表IPv6）决定下一层解析逻辑。
  - 在IP头中，根据Protocol字段（如6代表TCP，17代表UDP）确定传输层协议。

示例代码片段（P4语言）：

    ```
    parser MyParser {
        // 定义解析流程
        state start {
            transition parse_ethernet;
        }
        state parse_ethernet {
            packet.extract(hdr.ethernet);  // 提取以太网头
            transition select(hdr.ethernet.etherType) {
                0x0800: parse_ipv4;       // 若为IPv4，跳转到IPv4解析
                0x86DD: parse_ipv6;       // 若为IPv6，跳转到IPv6解析
                default: accept;          // 其他情况结束解析
            }
        }
        state parse_ipv4 {
            packet.extract(hdr.ipv4);     // 提取IPv4头
            transition select(hdr.ipv4.protocol) {
                6: parse_tcp;             // 若为TCP，继续解析TCP头
                17: parse_udp;            // 若为UDP，继续解析UDP头
                default: accept;
            }
        }
        // 其他状态定义...
    }
    ```

4. 动态调整能力

解析图的设计支持运行时重构，以适应网络协议的变化：

- 灵活扩展：用户可随时通过修改P4代码添加新协议解析逻辑，无需更换硬件。例如，在现有网络中引入新的隧道协议（如Geneve）。
- 条件分支解析：根据数据包内容动态选择解析路径。例如，在VLAN标签存在时解析VLAN头，否则跳过。

5. 实际应用示例

假设一个数据包携带以下头部结构：**以太网头 → VLAN标签 → IPv4头 → TCP头**

解析图工作流程：

- 初始状态：从**start**状态进入以太网头解析。
- 解析以太网头：提取目的MAC、源MAC和**EtherType**字段。
- 判断下一层协议：
  - 若**EtherType=0x8100**（VLAN标签），则解析VLAN头，更新EtherType字段。
  - 若**EtherType=0x0800**（IPv4），跳转到IPv4解析。
- 解析IPv4头：提取源IP、目的IP和**Protocol**字段。
- 判断传输层协议：若**Protocol=6**（TCP），继续解析TCP头（源端口、目的端口、序列号等）。
- 完成解析：所有相关头部字段被提取并存储，供后续匹配和动作阶段使用。

6. 解析图的优势与重要性

- 高效性：仅解析需要的字段，避免对无关数据的处理，减少资源消耗。
- 可维护性：协议变更仅需调整解析图定义，无需修改硬件逻辑。
- 兼容性：支持混合协议环境（如传统IPv4与新兴IPv6共存）。


解析图是RMT模型中实现协议无关性和灵活数据处理的核心机制。通过用户自定义的解析规则，它能够适应复杂多变的网络环境，为后续的匹配表查询和动作执行提供精确的输入数据。这种设计使得网络设备（如交换机、路由器）能够通过软件编程（如P4）快速响应新协议需求，是软件定义网络（SDN）和可编程数据平面的关键技术之一。


### 表图（Table Graph）

表图（Table Graph）是RMT（可重构匹配表）模型中的另一个核心抽象，用于定义数据包在匹配和动作执行阶段的逻辑流程。它描述了匹配表之间的依赖关系、动作执行顺序以及条件分支逻辑，确保数据包根据用户定义的策略高效处理。

1. 表图的基本定义

- 功能定位：表图位于解析图之后，负责指导数据包通过一系列匹配表（Match Tables），并根据匹配结果执行相应的动作（Actions）。
- 核心任务：
  - 定义多个匹配表的执行顺序（如先查L2表→再查L3表→最后查ACL表）。
  - 通过条件逻辑（如匹配成功/失败）控制流程跳转（例如匹配失败时丢弃数据包或跳转到其他表）。

2. 表图的组成元素

表图由以下关键组件构成：

- 匹配表（Match Tables）：用户自定义的规则集合，每条规则包含：
  - 匹配字段（Match Keys）：如目的MAC地址（L2表）、目的IP前缀（L3表）。
  - 匹配类型（Match Types）：如精确匹配（Exact）、最长前缀匹配（LPM）、范围匹配（Range）、三元匹配（Ternary）。
  - 动作（Actions）：匹配成功后执行的操作（如转发、修改TTL、添加VLAN标签）。
- 动作块（Action Blocks）：

  每个匹配表关联一个或多个动作，动作可以是：
  - 基础动作：内置操作（如forward、drop）。
  - 自定义动作：用户通过P4定义的复杂逻辑（如修改多个字段、调用外部函数）。
- 跳转逻辑（Transition Logic）：

  通过条件语句（如if-else）或优先级规则，控制数据包在不同表之间的流转路径。例如：
  - 若L2表匹配成功，则执行动作并跳转到L3表；
  - 若L3表匹配失败，则直接丢弃数据包。

3. 用户自定义表图（通过P4语言）

用户通过P4的**控制逻辑（Control Plane）**定义表图的结构。以下是一个简化的P4代码示例：

    ```
    control MyControl {
        // 定义匹配表及其动作
        table l2_table {
            key = {
                hdr.ethernet.dstMac: exact;  // 精确匹配目的MAC地址
            }
            actions = {
                set_l2_forward;  // 自定义动作：设置转发端口
                drop;            // 内置动作：丢弃数据包
            }
            default_action = drop;  // 默认动作为丢弃
        }

        table l3_table {
            key = {
                hdr.ipv4.dstAddr: lpm;  // 最长前缀匹配目的IP地址
            }
            actions = {
                set_next_hop;    // 自定义动作：设置下一跳IP
                decrement_ttl;   // 内置动作：减少TTL
            }
        }

        // 定义表图的执行流程
        apply {
            if (l2_table.apply().hit) {      // 先查L2表
                l3_table.apply();            // 若L2表匹配成功，再查L3表
                if (l3_table.apply().hit) {
                    // 执行L3表动作（如转发）
                } else {
                    drop();                 // 若L3表匹配失败，丢弃
                }
            } else {
                drop();                     // 若L2表匹配失败，直接丢弃
            }
        }
    }
    ```

解析以下表图:    
<figure style="text-align: center;">
<img src="/assets/img/l8p6.png" alt="Reconfigurable Tables : Table Graph" width="600">
<figcaption>Reconfigurable Tables : Table Graph</figcaption>
</figure>

3.1 组件定义

| 组件        | 说明                                                                                                |
|-------------|---------------------------------------------------------------------------------------------------------|
| VLAN        | 虚拟局域网，用于在二层网络中划分独立的广播域，隔离不同用户或业务流量。                                          |
| ETHERTYPE   | 以太网类型字段（2字节），指示数据帧载荷中封装的协议类型（如0x0800代表IPv4，0x86DD代表IPv6）。                   |
| MAC FORWARD | MAC地址转发逻辑，交换机或路由器根据目的MAC地址决定数据帧的转发端口。                                            |
| IPV4-DA     | IPv4目的地址，用于三层路由决策（最长前缀匹配）。                                                                |
| IPV6-DA     | IPv6目的地址，功能类似IPv4-DA，但地址空间更大且支持更灵活的路由策略。                                           |
| RCP         | 可能为路由控制协议（Routing Control Protocol），用于动态路由信息交换（如OSPF、BGP）。需结合上下文确认具体协议。 |
| ACL         | 访问控制列表，基于规则（如源/目的IP、端口号）过滤流量，允许或拒绝数据包通过。                                   |

3.2 依赖关系分析

箭头表示输入依赖，即下游组件的处理需要上游组件提供数据。具体流程如下：

- VLAN ← ETHERTYPE
    - 依赖逻辑：
        在解析数据帧时，首先读取ETHERTYPE字段：
        - 若ETHERTYPE=0x8100，表示数据帧包含VLAN标签，需先提取VLAN ID，再进行后续处理。
        - 若未携带VLAN标签，则直接进入MAC转发阶段。
    - 作用：VLAN划分依赖于ETHERTYPE字段的判断。
- MAC FORWARD ← IPV4-DA / IPV6-DA
    - 依赖逻辑：
    在二层转发（MAC FORWARD）完成后，若需进行三层路由，需提取IP头部的目的地址：
    - 若为IPv4数据包，使用IPV4-DA查询路由表。
    - 若为IPv6数据包，使用IPV6-DA查询路由表。
    - 作用：IP目的地址是三层路由决策的关键输入。
- RCP ← IPV4-DA / IPV6-DA
    - 依赖逻辑：
    动态路由协议（如OSPF、BGP）需要基于IP目的地址生成或更新路由表：
    - IPv4和IPv6地址分别对应不同的路由表项和协议处理逻辑。
    - 作用：路由控制协议依赖IP地址信息维护网络拓扑和路径选择。
- ACL ← 所有上游组件
    - 依赖逻辑：
    ACL规则可能基于以下字段进行匹配：
    - 二层：VLAN ID、源/目的MAC地址。
    - 三层：源/目的IPv4/IPv6地址。
    - 四层：TCP/UDP端口号。
    - 作用：ACL是流量过滤的最后一步，依赖所有前期解析的字段执行安全策略。

3.3 完整处理流程示例

数据帧进入设备：
解析ETHERTYPE字段，判断是否包含VLAN标签。
VLAN处理：
若存在VLAN标签，剥离并记录VLAN ID，用于后续流量隔离。
MAC地址转发：
根据目的MAC地址查询MAC表，确定输出端口（二层转发）。
IP路由决策：
提取IP头部中的目的地址（IPv4或IPv6），查询路由表确定下一跳。
路由协议交互：
通过RCP（如BGP）与其他设备交换路由信息，动态更新路由表。
ACL过滤：
根据预定义规则检查流量，允许合法数据包通过或丢弃非法流量。

3.4 关键依赖总结

VLAN与ETHERTYPE：VLAN划分需优先解析以太网类型字段。
MAC FORWARD与IP地址：三层路由依赖MAC转发后的IP头部信息。
RCP与IP地址：动态路由协议需基于IP地址更新路由表。
ACL的全局依赖：ACL规则综合所有层级字段实现细粒度过滤。

4. 表图的动态特性

- 运行时可重构：
  
  用户可通过P4动态修改匹配表的规则和动作，无需重启设备。例如：
  - 添加新的ACL规则以阻止特定IP流量。
  - 调整路由表的优先级以优化路径选择。
- 条件分支优化：
  表图支持复杂的逻辑分支，例如：
  - 根据数据包类型（如TCP/UDP）选择不同的处理路径。
  - 在匹配失败时触发备用表或默认策略。

5. 实际应用示例

假设一个数据包需要经过以下处理流程：**L2表（MAC转发） → L3表（IP路由） → ACL表（安全过滤）**

表图工作流程：

- L2表查询：
  - 匹配目的MAC地址，若命中则执行set_l2_forward动作（确定输出端口）。
  - 若未命中，直接丢弃数据包。
- L3表查询：
  - 匹配目的IP地址的最长前缀，若命中则执行set_next_hop和decrement_ttl。
  - 若未命中，丢弃数据包。
- ACL表查询：
  - 根据源IP、目的端口等字段进行三元匹配，若命中且动作为permit，则转发数据包；
  - 若动作为deny，则丢弃。

6. 表图的优势

- 逻辑清晰：通过图形化的表关系，直观展示数据包处理流程，便于调试和优化。
- 灵活扩展：支持插入新表或调整现有表顺序，适应网络策略变化（如新增安全检测模块）。
- 高效执行：通过条件跳转避免冗余查询，例如ACL表仅在特定流量条件下触发。

7. 表图与解析图的协同

- 数据传递：解析图提取的头部字段（如MAC地址、IP地址）作为输入，传递给表图中的匹配表。
- 端到端流程：
  - 解析图：结构化数据包头部 →
  - 表图：按顺序查询表并执行动作 →
  - 反解析器（Deparser）：重组数据包并发送。

表图是RMT模型中实现智能流量控制和策略执行的核心机制。通过用户自定义的匹配表与动作逻辑，它能够精确指导数据包的处理路径，满足复杂网络场景的需求（如多租户隔离、动态路由调整、细粒度安全策略）。结合解析图，表图构建了一个完整的可编程数据平面，为软件定义网络（SDN）和网络功能虚拟化（NFV）提供了强大的底层支持。

但解析和表格图只是模型的抽象,没有展示如何构建交换机.

### Match-Action Forwarding Model 匹配-动作转发模型

<figure style="text-align: center;">
<img src="/assets/img/l8p7.png" alt="Match-Action Forwarding Model" width="500"><img src="/assets/img/l8p7.png" alt="Match-Action Forwarding Model" width="500">
<figcaption>Match-Action Forwarding Model</figcaption>
</figure>

### RMT Logical to Physical Table Mapping RMT 逻辑到物理表映射

物理存储类型与匹配方式:

RMT 将逻辑表映射到两种物理存储结构，分别针对不同的匹配需求：

- **SRAM**: Used for **exact matching**
  - i.e., every bit must be either 0 or 1
- **TCAM**: Used for **ternary matching**, i.e.,can match “wildcard” bits
  - e.g., 128.84.*.* (Here * represents wildcard bits, i.e., they could be 0 or 1)
  - Typically used for Longest Prefix Matching for IP forwarding (Lecture 2)

| **存储类型** |     **匹配方式**    |                               **特点**                              |            **典型应用场景**           |
|:------------:|:-------------------:|:-------------------------------------------------------------------:|:-------------------------------------:|
| **SRAM**     | 精确匹配（Exact）   | - 要求所有匹配位严格为0或1 <br><br> - 速度快、功耗低，但容量有限            | MAC地址表、精确IP地址匹配（如流表）   |
| **TCAM**     | 三元匹配（Ternary） | - 支持通配符（*），允许部分位为“无关” <br><br> - 容量小、成本高，但灵活性强 | 最长前缀匹配（LPM）、ACL规则、QoS策略 |

### Action Processing Model 动作处理模型

### RMT Switch Specifications




## Packet Scheduling: PIEO
RMT 的一个局限性在于 RMT 仅专注于使数据包处理可编程, 也就是RMT把我们塞给他处理的东西全部当作是“packet”, 并不考虑别的, 比如packet排队/调度. 因此要决定先发哪个包后发哪个包, 需要新的方法.

> PIEO: A Fast, Scalable, and Programmable Packet Scheduler
