---
layout: post
title:  nginx和钓鱼网站
date:   2025-08-15
description: You’ll find this post in your `_posts` directory. Go ahead and edit it and re-build the site to see your changes. # Add post description (optional)
img: nginx.png # Add image post (optional)
tags: [Blog, Web]
author: # Add name author (optional)
---
# 本讲内容

- [本讲内容](#本讲内容)
  - [nginx 安装与简单熟悉](#nginx-安装与简单熟悉)
    - [Homebrew 安装 nginx](#homebrew-安装-nginx)
    - [Homebrew 启动 nginx](#homebrew-启动-nginx)
    - [访问nginx服务页面](#访问nginx服务页面)
  - [nginx 代理](#nginx-代理)
    - [正向代理](#正向代理)
    - [反向代理](#反向代理)
    - [总结](#总结)
  - [nginx 使用](#nginx-使用)
    - [静态网站配置](#静态网站配置)
    - [基于端口的多虚拟主机](#基于端口的多虚拟主机)
    - [访问日志](#访问日志)
    - [代理与中介](#代理与中介)
  - [MacOS 配置](#macos-配置)
    - [使用8080 显示自己的页面](#使用8080-显示自己的页面)
    - [恢复默认8080, 另外开自己的页面](#恢复默认8080-另外开自己的页面)
    - [多个server](#多个server)
    - [日志配置和使用](#日志配置和使用)

Web 网络服务是一种被动访问的服务程序，即只有接收到互联网中其他主机发出的 请求后才会响应，最终用于提供服务程序的Web 服务器会通过 HTTP（超文本传输协议））或 HTTPS（安全超文本传输协议）把请求的内容传送给用户。
目前能够提供 Web 网络服务的程序有 II5、Nginx 和 Apache 等。其中，IIS（Iinternet Information Services，互联网信息服务）是Windows 系统中默认的Web 服务程序. 
2004年10月4日，为俄罗斯知名门户站点而开发的 Web 服务程序 Nginx 横空出世。Nginx 程序作为一款轻量级的网站服务软件，因其稳定性和丰富的功能而快速占领服务器市 场，但 Nginx 最被认可的还当是系统资源消耗低且并发能力强，因此得到了国内诸如新浪、网易、腾讯等门户站的青睐。

web服务器(nginx): 接受http请求并返回数据

web框架(django, flask): 开发web应用程序, 处理接收到的数据.

## nginx 安装与简单熟悉

### Homebrew 安装 nginx

- brew搜索软件命令： brew search nginx  
-  brew安装软件命令： brew install nginx
-   brew卸载软件命令:  brew uninstall nginx

**nginx -v**  验证 nginx 是否安装成功， 若显示版本信息则证明安装成功。

### Homebrew 启动 nginx

```
% brew services start nginx  # 启动
% brew services stop nginx   # 停止
% brew services list    # 查看状态
```
==> Successfully started `nginx` (label: homebrew.mxcl.nginx)

验证nginx是否正常启动, 检查机器的进程信息和端口信息:

```
% ps -ef  # 查看所有进程信息
% ps -ef | grep "nginx"  # grep过滤命令, 只查看nginx 
% netstat -tunlp | grep "nginx"  # 查看端口信息, nginx默认80端口
```

**MacOS查看端口:**

```
% cat /opt/homebrew/etc/nginx/nginx.conf | grep listen
% sudo lsof -i -P | grep nginx
```

<figure style="text-align: center;">
<img src="/assets/img/nginx1.png" alt="" width="400">
<figcaption>MacOS查看nginx进程和端口</figcaption>
</figure>


### 访问nginx服务页面

浏览器访问: http://[自己机器的ip地址]:8080

如果修改这个网站的显示内容, 甚至仿冒真实网站界面，就能导致欺骗消费者或者窃取访问者提交的账号和密码信息。钓鱼网站一般只有一个或几个页面，和真实网站差别细微。

首先尝试利用curl命令, 发起http网络请求并且验证对方网站的信息:

```
curl https://www.taobao.com
curl -I https://www.taobao.com  # 可以看到web服务器信息(https://tengine.taobao.org)

curl -I 10.0.0.94:8080    
```

<figure style="text-align: center;">
<img src="/assets/img/nginx3.png" alt="" width="500">
<figcaption>查看淘宝网进程和端口</figcaption>
</figure>


<figure style="text-align: center;">
<img src="/assets/img/nginx2.png" alt="" width="400">
<figcaption>查看自己机器nginx进程和端口</figcaption>
</figure>


<figure style="text-align: center;">
<img src="/assets/img/nginx4.png" alt="" width="400">
<figcaption>查看nginx安装文件和路径信息</figcaption>
</figure>

```
% rpm -ql nginx | grep "index"  # Linux系统
```

如果使用某些方法修改index.html的内容, 如vim, 就可以仿冒网站内容.


---

## nginx 代理

http和https的区别：

http协议：协议以明文方式发送数据，不提供任何方式的数据加密。不适合传输一些敏感信息，例如密码。其使用的端口是80。
https协议：在http协议的基础上，加入了SSL（Secure Sockets Layer），用于对数据进行加密。其使用的端口为443。

默认nginx只支持http. 要支持https, 可以使用第三方模块[ngx_http_proxy_connect_module][ngx_http_proxy_connect_module]

[ngx_http_proxy_connect_module]: https://github.com/chobits/ngx_http_proxy_connect_module

如果要为Nginx添加第三方模块，需要在配置configure时添加--add-module。从Nginx1.9.11版本开始，支持load_module指令来动态加载模块。

先放两个链接, 有空实现一下:

[Nginx之正向代理与反向代理][Nginx之正向代理与反向代理]
[Nginx之正向代理与反向代理进阶（支持https）][Nginx之正向代理与反向代理进阶（支持https）]

[Nginx之正向代理与反向代理]: https://zhuanlan.zhihu.com/p/629196365
[Nginx之正向代理与反向代理进阶（支持https）]: https://zhuanlan.zhihu.com/p/629353778

### 正向代理

在正向代理过程中，代理服务器代理的是客户端，我们将客户端和代理服务器看作是一个整体，客户端知晓真实服务端地址，但是无法直接访问，因此通过代理服务器向服务端发送请求，服务端并不知晓真实客户端的信息。比如我想访问 Google来搜索关键词“Nginx”，但是国内现在不允许访问Google。但是我能访问国外的一台服务器（代理服务器），这台服务器能够访问 Google。于是我先连上代理服务器，告诉它我需要访问 Google 来搜索关键词“Nginx”，代理服务器去请求访问之后，然后返回给我。从网站的角度，只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求，也隐藏来用户的资料，这取决于代理告不告诉服务器端。
结论就是：正向代理：客户端 <一> 代理 一>服务端

<figure style="text-align: center;">
<img src="/assets/img/nginx17.png" alt="" width="400">
<figcaption>nginx正向代理</figcaption>
</figure>

正向代理，是一个位于客户端和原始服务器（origin server）之间的服务器，为来从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原始服务器）, 然后代理向原始服务器转交请求并将获得的内容返回给客户端。

Nginx的正向代理功能允许局域网中的客户端通过代理服务器访问Internet资源。具体来说，Nginx作为一种流行的Web服务器和反向代理服务器，在正向代理方面的应用也相当实用。以下是其正向代理功能的几个关键点：

- 访问外部资源：在正向代理的配置下，Nginx作为代理服务器，帮助内部网络的用户访问外部互联网上的资源。
- 安全性：通过正向代理，可以对内部用户的上网行为进行监控和管理，提高网络安全性。
- 配置简便：客户端需要配置代理服务器的信息，以便通过Nginx访问指定网站。
- 提高访问速度：代理服务器可以缓存经常访问的资源，从而提高后续请求的响应速度。
- 隐藏客户端信息：正向代理可以隐藏客户端的真实IP地址，增加匿名性。
- 负载均衡：虽然不直接属于正向代理的功能，但Nginx还可以用作负载均衡器，分散到多个服务器上，提高网站的可用性和稳定性。

我们正常上网就是一种正向代理。 


### 反向代理

在反向代理过程中，代理服务器代理的服务端，我们将代理服务器和服务端看作是一个整体，客户端无法知晓真实服务端的地址，只能通过代理服务器进行访问，服务端通过代理服务器接收并响应请求。

<figure style="text-align: center;">
<img src="/assets/img/nginx18.png" alt="" width="400">
<figcaption>nginx反向代理</figcaption>
</figure>

例如：用户访问 http://www.test.com/readme，但 www.test.com 上并不存在 readme 资源，它是偷偷从另外一台服务器上取回来，然后作为转交的内容返回给用户，但用户并不知情。这里所提到的 www.test.com 这个域名对应的服务器就设置来反向代理功能。
结论就是：客户端 一>代理 <一> 服务端
反向代理正好相反，对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理命名空间（name-space）中的内容发送普通请求，接着反向代理将判断向何处（原始服务器）转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。



### 总结

正向代理和反向代理的区别在于代理的对象不一样，正向代理的代理对象是客户端，反向代理的代理对象是服务端。总结一下：

- 代理服务器站在客户端那边就是正向代理. 正向代理即是客户端代理，代理客户端，服务端不知道实际发起请求的客户端。
- 代理服务器站在服务器那边就是反向代理. 反向代理即是服务端代理，代理服务端，客户端不知道实际提供服务的服务端。
- Nginx 通过 proxy_pass 可以设置代理服务。

---

## nginx 使用

### 静态网站配置

MacOS路径: /opt/homebrew/Cellar/nginx/1.27.5/html/index.html

nginx.conf 路径: /opt/homebrew/etc/nginx/nginx.conf

### 基于端口的多虚拟主机

在一个nginx下基于多个端口可以处理多个网站的内容: 修改配置文件,重启即可, 仍然是nginx.conf. 当然路径里面要有东西.

nginx.conf中一个虚拟主机(server块)就代表支持一个网站

### 访问日志

nginx能记录用户的每一次访问请求, 可以掌握服务器的动态信息; 可以对用户行为进行监测分析, 如访问时间/次数/频率.

仍然是修改配置nginx.conf:

```
# 如果只有一个虚拟主机, 只需要在server块中把 access_log 打开.
# 如果有多个虚拟主机, 要关注nginx.conf的层级关系

http{

    # 日志功能写在这里, 对以下所有网站都适用

    # 虚拟主机1
    server{

    }

    # 虚拟主机2
    server{


    }

    # 日志功能的具体配置如下

    include mime.types;
    default_type application/octet-stream;
    
    log_format main '$remote_addr - $remote_user [$time_local] "$request"
                    '$status $body_bytes_sent "$http_referer" '
                    '"Shttp_user_agent" "$http_X_forwarded_for"*;
    access_log logs/access.log main;

    # -t 检查修改后的配置语法是否正确
    # -s reload 重启nginx
    # tail -f 监测
}
```

<figure style="text-align: center;">
<img src="/assets/img/nginx19.png" alt="" width="400">
<figcaption>如果是单个虚拟主机, 只需要去掉access_log行注释即可</figcaption>
</figure>

<figure style="text-align: center;">
<img src="/assets/img/nginx20.png" alt="" width="400">
<figcaption>多个虚拟主机要在外层配置</figcaption>
</figure>

MacOS 日志路径: /opt/homebrew/var/log/nginx/access.log

<figure style="text-align: center;">
<img src="/assets/img/nginx21.png" alt="" width="400">
<figcaption>查看日志</figcaption>
</figure>

### 代理与中介

修改nginx.conf

编辑server块中location部分: 

```
location / {
    proxy_pass 代理网址;
}
```

保存退出, 仍然可以先检查语法是否正确: /opt/homebrew/etc/nginx/nginx.conf -t.



## MacOS 配置

### 使用8080 显示自己的页面

启动

```
sudo brew services start nginx
# 访问localhost:8080，若出现欢迎界面，说明成功安装和启动
```

<figure style="text-align: center;">
<img src="/assets/img/nginx5.png" alt="" width="400">
<figcaption>启动nginx</figcaption>
</figure>

localhost:8080已经正常访问, 我们还是检查一下端口号:

/opt/homebrew/etc/nginx/nginx.conf

<figure style="text-align: center;">
<img src="/assets/img/nginx6.png" alt="" width="400">
<figcaption>检查nginx端口</figcaption>
</figure>

找到 Nginx 所在目录, 注意这里不是 nginx.conf 的目录, 而是 Nginx 的安装目录, 执行指令: brew info nginx , 如下图所示:

<figure style="text-align: center;">
<img src="/assets/img/nginx7.png" alt="" width="400">
<figcaption>找到安装目录</figcaption>
</figure>

其中 /opt/homebrew/Cellar/nginx/1.27.5 是安装目录, /opt/homebrew/etc/nginx/nginx.conf 是配置文件目录. 我们用到的是 nginx 的安装目录.

打开此目录: open /opt/homebrew/Cellar/, 将你的前端文件复制到此目录下的 html 文件下, 如下图:

<figure style="text-align: center;">
<img src="/assets/img/nginx8.png" alt="" width="400">
<figcaption>自己的前端文件</figcaption>
</figure>

注意 /opt/homebrew/Cellar/nginx/1.27.5 中的html(alias)文件夹就是/www

<figure style="text-align: center;">
<img src="/assets/img/nginx9.png" alt="" width="400">
<figcaption>nginx安装目录</figcaption>
</figure>

此时再次修改 nginx.conf 文件, 目的是找到你的 前端 文件, nginx.conf 的打开方式上面已经说了, 就是打开修改端口号的那个文件:

指定前端项目所在位置: 我的前端文件就是 html/jingyi , 开启页面我的文件也正好叫做index.html, 按需修改即可, 注意如果有改端口, 这里也要同步修改.

<figure style="text-align: center;">
<img src="/assets/img/nginx11.png" alt="" width="400">
<figcaption>按自己的配置修改.conf</figcaption>
</figure>

部署完要记得重启一下 nginx, 重启指令 sudo nginx -s reload, 刷新一下html, 就可以看到自己的页面了. 我这个是随便拿了两年前写的东西.

<figure style="text-align: center;">
<img src="/assets/img/nginx12.png" alt="" width="400">
<figcaption>可以看到自己的页面</figcaption>
</figure>

### 恢复默认8080, 另外开自己的页面

测试 mac 本机新增一个虚拟主机. 首先将server块内容改为默认, 8080显示回默认页面. 

<figure style="text-align: center;">
<img src="/assets/img/nginx15.png" alt="" width="400">
<figcaption>默认设置</figcaption>
</figure>

在该server块下方新建, 修改为自己的配置:

<figure style="text-align: center;">
<img src="/assets/img/nginx16.png" alt="" width="400">
<figcaption>自己的配置</figcaption>
</figure>

重启nginx:


<figure style="text-align: center;">
<img src="/assets/img/nginx13.png" alt="" width="400"><img src="/assets/img/nginx14.png" alt="" width="400">
<figcaption>自己的页面端口变成了8081</figcaption>
</figure>

当然也可以多个虚拟主机使用. 现在我的 server 虚拟主机都是放在当前 nginx.conf 文件中，如果当有很多的虚拟主机的时候，我们可以将这些配置虚拟主机单独放在一个文件里面进行配置，然后 include 到 nginx.conf 文件中即可.


### 多个server

先熟悉一下httpd.conf内容:

```
# ------------------------------------- 全局配置

# Nginx worker 进程运行的用户及用户组
# 语法：user username[groupname]    默认：user nobody nobody
# user用于设置master进程启动后，fork出的worker进程运行在那个用户和用户组下。当按照"user username;"设置时，用户组名与用户名相同。
# 若用户在 configure 命令执行时，使用了参数 --user=usergroup 和 --group=groupname ,此时 nginx.conf 将使用参数中指定的用户和用户组。
#user  nobody;

# Nginx worker 进程个数：其数量直接影响性能。
# 推荐设置：cpu的个数 * 核心数(几核CPU)
# 每个 worker 进程都是单线程的进程，他们会调用各个模块以实现多种多样的功能。如果这些模块不会出现阻塞式的调用，那么，有多少CPU内核就应该配置多少个进程，反之，有可能出现阻塞式调用，那么，需要配置稍多一些的worker进程。
worker_processes  1;

# ssl硬件加速。
# 用户可以用 OpneSSL 提供的命令来查看是否有ssl硬件加速设备：openssl engine -t
#ssl_engine device;

# 守护进程(daemon)。是脱离终端在后台允许的进程。它脱离终端是为了避免进程执行过程中的信息在任何终端上显示。这样一来，进程也不会被任何终端所产生的信息所打断。##
# 关闭守护进程的模式，之所以提供这种模式，是为了放便跟踪调试 nginx，毕竟用gdb调试进程时最繁琐的就是如何继续跟进fork出的子进程了。##
# 如果用 off 关闭了 master_proccess 方式，就不会fork出 worker 子进程来处理请求，而是用 master 进程自身来处理请求
#daemon off;   		# 查看是否以守护进程的方式运行 Nginx 默认是 on 
#master_process off;    # 是否以 master/worker 方式工作 默认是 on


# error 日志的设置
# 语法：error_log path/file level;
# 默认：error_log logs/error.log error;
# 当 path/file 的值为 /dev/null 时，这样就不会输出任何日志了，这也是关闭 error 日志的唯一手段；
# leve 的取值范围是 debug、info、notice、warn、error、crit、alert、emerg 从左至右级别依次增大。
# 当 level 的级别为 error 时，error、crit、alert、emerg 级别的日志就都会输出。大于等于该级别会输出，小于该级别的不会输出。
# 如果设定的日志级别是 debug，则会输出所有的日志，这一数据量会很大，需要预先确保 /path/file 所在的磁盘有足够的磁盘空间。级别设定到 debug，必须在 configure 时加入 --with-debug 配置项。
#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

# pid文件的路径（master进程ID的pid文件存放路径）
#pid        logs/nginx.pid;

# ------------------------------------- 事件配置

events {
		
    # 仅对指定的客户端输出 debug 级别的日志： 语法：debug_connection [IP || CIDR]
    # 这个设置项实际上属于事件类配置，因此必须放在 events{……} 中才会生效。它的值可以是 IP 地址或者 CIRD 地址。
    # 这样，仅仅以下IP地址的请求才会输出 debug 级别的日志，其他请求仍然沿用 error_log 中配置的日志级别
    # 注意：在使用 debug_connection 前，需确保在执行 configure 时已经加入了 --with-debug 参数，否则不会生效。
    #debug_connection 10.224.66.14;  # 或是 debug_connection 10.224.57.0/24
  
    # 单个 cpu 进程的最大并发连接数(一个进程的并发量)
    # 根据硬件调整，合前面工作进程配合起来用，尽量大，但是别把 cpu 跑到 100% 就行
    # 同时要考虑，服务器并不是 100% 为 nginx 服务，还有其他工作要做，因此不能达到理论峰值
    # max_clients(并发总数) = worker_processes * worker_connections
    worker_connections  1024;
}

# 核心转储(coredump): 在 Linux 系统中，当进程发生错误或收到信号而终止时，系统会将进程执行时的内存内容(核心映像)写入一个文件(core文件)，以作为调试只用，这就是所谓的核心转储(coredump)

# ------------------------------------- HTTP配置

http {
    # 嵌入其他配置文件
    # 语法：include /path/file 绝对路径，指定目录下的指定文件
    # 语法：include path/file 相对路径，指定目录下的指定文件
    # 语法：include path/* 指定目录下的所有文件
    # 语法：include file 当前 nginx.conf 同文件夹下的指定文件
    # 参数既可以是绝对路径也可以是相对路径（相对于 nginx 的配置目录，即 nginx.conf 所在的目录
    include       mime.types;
    
    # 响应文件类型
    default_type  application/octet-stream;
  	
    # 日志格式
    # 语法：log_format 格式名称 格式样式(可以多个)
    # log_format 与 access_log 既可以配置在 http{ ... }里面，也可以配置在虚拟主机 server{ ... } 里面
    # 日志格式样式文章尾部有介绍常用的
    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                  '$status $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';
    # 例如在加一个日志配置 
    # log_format mylog '$remote_addr - $remote_user - $http_user_agent'
    
    # 日志文件的存放路径、格式、缓存大小
    # 语法：access_log 日志存放路径 存放日志的配置格式
    # log_format 与 access_log 既可以配置在 http{ ... }里面，也可以配置在虚拟主机 server{ ... } 里面
    #access_log  logs/access.log  main;
    # 例如在加一个日志配置 
    # access_log logs/access.log  mylog;
    
    # 是否使用 sendfile 系统调用来传输文件
    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    # 超时时间
    keepalive_timeout  65;

    #gzip  on;
    
    # 每一个 server 就是一个虚拟主机，虚拟站点
    server {
    
        # 监听的端口
        listen       8080;
        
        # 主机名称：其后可以跟多个主机名称，开始处理一个HTTP请求时，nginx 会取出 header 头中的 Host，与每个 server 中的 server_name 进行匹配，以此决定到底由那一个 server 来处理这个请求。
        # 有可能一个 Host 与多个 server 块中的 server_name 都匹配，这时会根据匹配优先级来选择实际处理的 server 块。
        # server_name 与 Host 的匹配优先级见文末。
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;
  	
        # 当浏览器输入地址访问服务器的时候，就会进入到这个里面来匹配
        # 语法：location [=|~|~*|^~] patt { ... }
        # 中括号可以不写任何参数，此时为一般匹配。
        # 匹配类型按大类型可以分为3种：
        # 精确匹配: location = patt { ... }
        # 一般匹配: location patt { ... }
        # 正则匹配: location ~ patt { ... } 例如：location ~ \.(gif|bmp|jpg)$ { ... }
        # location 的使用实例见文末。
        # 注意：location 是有顺序的，当一个请求有可能匹配多个 location 时，实际上这个请求会被第一个 location 处理。
        location / {
            # 匹配的根目录，只写文件名默认在 /nginx 文件夹下
            # 也可以写成绝对路径 root /usr/local/var/dzm;
            root   html;
            # 设置默认首页，按先后顺序匹配首页
            index  index.html index.htm;
        }

        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

        # proxy the PHP scripts to Apache listening on 127.0.0.1:80
        #
        #location ~ \.php$ {
        #    proxy_pass   http://127.0.0.1;
        #}

        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
        #
        #location ~ \.php$ {
        #    root           html;
        #    fastcgi_pass   127.0.0.1:9000;
        #    fastcgi_index  index.php;
        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
        #    include        fastcgi_params;
        #}

        # deny access to .htaccess files, if Apache's document root
        # concurs with nginx's one
        #
        #location ~ /\.ht {
        #    deny  all;
        #}
    }

    # another virtual host using mix of IP-, name-, and port-based configuration
    #
    #server {
    #    listen       8000;
    #    listen       somename:8080;
    #    server_name  somename  alias  another.alias;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}

    # HTTPS server
    #
    #server {
    #    listen       443 ssl;
    #    server_name  localhost;

    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;

    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;

    #    ssl_ciphers  HIGH:!aNULL:!MD5;
    #    ssl_prefer_server_ciphers  on;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}
    include servers/*;
}


```

我们可以在nginx.conf所在文件夹内新建一个/server/server.conf, 存放我们的虚拟主机. 在上面配置文件里最尾部我们已经配置了 include servers/*;,也就相当于导入 servers 文件夹内的所有文件。

在server.conf中编辑好server块即可. 如果想要设置别名, 在域名后面以空格隔开即可

```
server {
  listen 端口号;
  server_name 域名 别名1 别名2;
  location / {
    root 路径;
    index index.html;
  }
}
```

记得配置好之后要刷新nginx: nginx -s reload.


### 日志配置和使用

在 http{ ... } 里面在配置一个 log_format 与 access_log:

```
http {
  ......
  log_format mylog  '$remote_addr - $request - $status - $http_user_agent';
  access_log test.access.log mylog;
  server {
  ...
  }
}
```

刷新一下当前服务器配置的网页，然后就拿到对应的日志了. 这里是通过 HomeBrew 安装的 Nginx, 所以日志路径都是软链接，在 Linux 里面就不会这样了，其实无论什么系统，只要区分好相对路径跟绝对路径就不会乱，日志路径.

参考log格式:[日志][log]

[log]:https://juejin.cn/post/6883355186790662158