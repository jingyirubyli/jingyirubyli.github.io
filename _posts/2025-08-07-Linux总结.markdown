---
layout: post
title:  Linux总结
date:   2025-08-07
description: You’ll find this post in your `_posts` directory. Go ahead and edit it and re-build the site to see your changes. # Add post description (optional)
img: linux.png # Add image post (optional)
tags: [Blog]
author: # Add name author (optional)
---
# 本讲内容

Linux: 一套开源的C语言文件, 支持多用户同时操作, 多任务, 支持多CPU, 多线程的操作系统, 类Unix(Unix使用收费,商业化). 主要用在服务器端、 无人机/物流机器人等嵌入式开发、 个人PC桌面等.

指令(人发明的) --> shell/bash解释器 --> 计算机可以理解的机器码 --> 计算机硬件识别机器码并执行动作 --> 输出结果,用户看到结果 

Unix技术成熟,可靠性高, 可伸缩性强, 支持很多CPU架构包括intel/amd/hp等. 强大的网络功能: TCP/IP协议就是基于Unix开发. 强大的数据库能力: Oracle/DB2/mysql等. 强大的开发能力: C/java等

<figure style="text-align: center;">
<img src="/assets/img/linux1.png" alt="" width="500">
<figcaption>Unix-Linux-iOS-Andorid-鸿蒙</figcaption>
</figure>

自由软件: 没有商业化的版权制约, 源代码自由开放, 可以自由传播. 比如redhat linux自由传播,但不免费完全使用. centos linux是自由传播且完全免费.

自由软件基金会FSF(free software foundation) 发起 [GNU][gnu] 活动: 建立一套完全自由可移植的类Unix操作系统. gnu的组件迁移到了linux, 如gcc编译器, bash解释器, gawk命令等.

[gnu]: https://www.gnu.org

GPL(General Public License) 通用公共许可

这篇内容在MacOS上介绍, 用 VM Ware 装一个Linux也很简单, 我之前装了一个, 觉得那个紫红色界面太丑了就删了(绿色青蛙五个字...).

- [本讲内容](#本讲内容)
  - [Linux 的一些基础](#linux-的一些基础)
    - [几个基础命令](#几个基础命令)
    - [目录结构](#目录结构)
    - [一些重要的配置文件(etc中)](#一些重要的配置文件etc中)
  - [Linux 用户权限](#linux-用户权限)
    - [文件的属性以及文件属主和属组](#文件的属性以及文件属主和属组)
    - [更改文件属性](#更改文件属性)
  - [Linux 文件与目录管理](#linux-文件与目录管理)
    - [ls](#ls)
    - [cd](#cd)
    - [pwd](#pwd)
    - [mkdir](#mkdir)
    - [rmdir](#rmdir)
    - [rm](#rm)
    - [mv](#mv)
    - [cp](#cp)
  - [Linux 文件内容查看](#linux-文件内容查看)
    - [cat/tac](#cattac)
    - [nl](#nl)
    - [more](#more)
    - [less](#less)
    - [head/tail](#headtail)
  - [Linux 用户和用户组管理](#linux-用户和用户组管理)
    - [Linux系统用户账号的管理](#linux系统用户账号的管理)
    - [Linux系统用户组的管理](#linux系统用户组的管理)
    - [与用户账号有关的系统文件](#与用户账号有关的系统文件)
  - [Linux 磁盘管理](#linux-磁盘管理)
  - [vi/vim](#vivim)
  - [yum](#yum)
  - [apt](#apt)

---

## Linux 的一些基础

### 几个基础命令

-a: all, 列出所有文件包括隐藏文件

-l: 列出详细信息

whoami: 显示当前登录的用户

hostname: 显示当前机器的主机名

pwd: 显示当前的工作目录绝对路径


### 目录结构

第一个/表示根目录, 后面的/表示分割.

<figure style="text-align: center;">
<img src="/assets/img/linux2.png" alt="" width="500">
<figcaption>文件目录</figcaption>
</figure>

**/:**
根目录

顾名思义，根目录就是所有目录所在的目录，它是Linux中所有目录的根，从某种概念上讲，它有点类似于Windows中的磁盘驱动器符号。之后将会看到，所有其他目录都是以/开头的。

**/bin：**
存放重要的用户二进制文件目录

bin是binary的缩写，/bin目录存放了非常重要的用户二进制文件，其实就是一些程序。需要特别说明的是，/bin中存放的都是在单用户维护模式下还能被操作的命令，这些命令可以被root和普通用户使用。在/bin中我们可以看到例如chmod、du这些我们经常使用的Linux命令程序。bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令.

**/boot：**
存放系统启动时需要文件的目录

/boot中存放的主要是系统启动时需要用到的文件，比如EFI、GRUB以及Linux内核。这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。

**/dev ：**
设备文件目录. Linux将所有东西都看成文件，设备也不例外，不论是实体的硬件设备还是虚拟设备。实体硬件比如第一块被检测到的硬盘会被挂载到/dev/sda，第二块会被挂载到/dev/sdb，以此类推。虚拟设备比如null、random、stderr、stdin和stdout。
dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。

**/etc：**
配置文件目录

etc的含义是Et cetera，表示一些相关的其他东西，/etc从UNIX早期开始就被用来存放配置文件，一直沿用至今。需要注意的是，/etc中存放的是系统配置文件，特定用户的配置文件放在每个用户的/home目录下。etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。

**/home：**
用户目录

/home目录中存放的是每个用户的用户目录，比如有一个用户叫tom，/home/tom就是他的用户目录，每个用户的用户目录中存放的用户数据和用户配置文件，比如每个用户的.bashrc文件、.ssh目录等。普通用户只能访问自己的用户目录而不能访问别人的，root用户则没有此限制。
用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。

**/lib：**
重要的共享库目录

/lib目录中存放的是/bin和/sbin中那些重要的二进制文件（程序）需要的共享库。另外/usr/bin中二进制文件（程序）需要的共享库都存放在/usr/lib。lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。

**/lost+found：**
恢复文件目录

每个Linux文件系统都有/lost+found目录，当文件系统崩溃时，在下次启动时将会进行文件系统自检，任何在崩溃过程中损坏的文件都将被放入/lost+found，你可以尝试找到并恢复这些文件。这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。

**/media：**
可删除媒介目录

当你将一些可删除媒介挂（比如CD，U盘，光驱等）载到计算机上时，系统会在/media下自动创建子目录，之后就可以通过访问这个子目录来访问媒介。比如你在电脑上插入CD，在/media目录下就会自动生成一个子目录，你可以通过访问这个子目录来访问CD的内容。linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。

**/mnt：**
临时挂载点目录

mnt是mount的缩写，各种设备挂载到系统后，会在/mnt目录下生成相应设备的目录，比如挂载光驱、文件系统、CD等。
系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。

**/opt：**
可选包目录

opt是Optional的意思，系统中安装的可选软件包被存放在/opt目录中。opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。
**/proc：**
内核和进程文件目录

/proc是一个虚拟目录，并不包含任何标准文件。当系统启动后，会对当前内核和硬件信息进行检测，并将这些信息放在这个目录中（其实都在内存中）。你可以使用cat /proc/meminfo来查看关于内存的一些信息，或者使用cat /proc/version来查看Linux内核信息。proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。
这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：

```
echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all
```

**/root：**
root用户的home目录

和一般用户的home目录放在/home/{用户名}不同，root用户的home目录专门被放在/root。该目录为系统管理员，也称作超级权限者的用户主目录。

**/run：**
应用程序状态目录

/run目录用来存放应用程序在运行期间需要的一些短暂存在的文件，比如socket和pid文件，这些文件对这些应用程序的运行很重要，因此不能把他们放在/tmp目录下，因为/tmp目录下的文件有可能会被系统清空。是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。

**/sbin：**
系统管理员用的二进制文件目录

/sbin目录和/bin目录有些类似，都是存放二进制文件。比较特殊的是，/sbin目录存放的都是系统管理的命令程序，一般只有root用户能使用。s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。

**/srv：**
服务数据目录

/srv目录主要用来存放一些系统提供的网络服务的数据，如果你在机器上运行一个HTTP服务器来对外提供静态文件时，/srv/http目录将存放这些静态文件，如果你运行一个FTP服务器对外提供文件，则/srv/ftp目录将存放这些文件。

该目录存放一些服务启动之后需要提取的数据。

**/tmp：**
临时文件目录

应用程序会将一些临时文件存放在/tmp目录中，一般来说当系统重启后，/tmp下的文件会被自动清空，也会被一些监控程序清空。tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。

**/usr：**
用户二进制文件和只读文件目录

/usr目录下存放的是用户使用的程序，可以很明显地发现，Linux将普通用户和系统使用的程序分开存放，比如上面提到过，系统使用的一些重要程序存放在/bin，而那些不重要的程序就被放在/usr/bin。不太重要的系统管理程序存放在/usr/sbin而不是/sbin。usr也被称为UNIX Software Resource，这是比较早期的说法。下面是/usr目录下常见的几个子目录的含义：

- /usr/bin 存放用户命令
- /usr/include 存放编程语言的头文件和包含文件
- /usr/lib 存放各个应用程序的库函数和目标文件
- /usr/local 存放系统管理员下载的软件的安装目录
- /usr/sbin 存放不常用的系统命令
- /usr/src 存放源码
usr 是 unix system resources(unix 系统资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。

**/var：**
变动数据目录

/var一般用来存放经常变动的数据，比如日志文件和缓存文件。下面是/var目录下常见的几个子目录的含义：

- /var/cache 存放应用程序运行产生的临时文件
- /var/lib 存放程序在执行过程中需要使用到的数据文件，每个软件在此目录下都有自己独自的目录
- /var/lock 存放程序的锁状态
- /var/log 存放各种日志文件
- /var/mail 存放个人电子邮箱
- /var/run 有些程序在运行后，会将他们的pid、socket文件放置到这个目录中

var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。

**/selinux：**
 这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。

**/sys：**
这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。
sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。
该文件系统是内核设备树的一个直观反映。
当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。



在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。
/etc： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。
/bin, /sbin, /usr/bin, /usr/sbin: 这是系统预设的执行文件的放置目录，比如 ls 就是在 /bin/ls 目录下的。
值得提出的是 /bin、/usr/bin 是给系统用户使用的指令（除 root 外的通用用户），而/sbin, /usr/sbin 则是给 root 使用的指令。
/var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 /var/log 目录下，另外 mail 的预设放置也是在这里。

### 一些重要的配置文件(etc中)

在 macOS 上，找不到 /etc/sysconfig 这个目录，是因为它是 Linux（尤其是 Red Hat/CentOS 系列） 特有的配置目录，macOS 并没有这个路径。

macOS 基于 BSD（Darwin 内核），系统配置文件的位置和结构与 Linux 不同，所以对应的配置通常在这些地方：

|      **Linux /etc/sysconfig 的作用**     |                 **macOS 对应位置/文件**                 |
|:----------------------------------------:|:-------------------------------------------------------:|
| 网络配置 /etc/sysconfig/network-scripts/ |  /etc/hosts、/etc/resolv.conf，或用 系统偏好设置 → 网络 |
|               系统服务配置               | /Library/LaunchDaemons/、/System/Library/LaunchDaemons/ |
|               环境变量设置               |              ~/.zshrc（或 ~/.bash_profile）             |

如果将 /etc/resolv.conf中的nameserver注释掉,那么他就没有域名解析功能了, 此时ping baidu.com 会报错: 未知的名称或服务. 但是他仍然可以上网, 因为可以ping公网ip

<figure style="text-align: center;">
<img src="/assets/img/linux3.png" alt="" width="500">
<figcaption>ping baidu.com</figcaption>
</figure>

Linux直接用 cat /etc/hostname 读取主机名称. MacOS 会在 /etc/hosts 和 /etc/hostname 里保存信息，不过很多时候 /etc/hostname 并不存在，因为主机名是动态从系统设置里读的。可以用 scutil 命令（macOS 专用）:

```
scutil --get HostName      # 系统自定义的主机名
scutil --get LocalHostName # Bonjour 名称
scutil --get ComputerName  # 在“共享”里显示的名字
```

<figure style="text-align: center;">
<img src="/assets/img/linux4.png" alt="" width="500">
<figcaption>hostname</figcaption>
</figure>

<figure style="text-align: center;">
<img src="/assets/img/linux5.png" alt="" width="500">
<figcaption>cat hosts</figcaption>
</figure>

Linux中的motd文件会显示welcome, 在 macOS 上，/etc/motd（Message of the Day）文件确实存在，不过默认是空的或不存在，因为 macOS 登录时不会像传统 Linux 一样自动显示 MOTD，需要你用 ssh localhost 登录本机才会看到。总之如果你是想找 Linux 教程里那种 SSH 登录显示 MOTD 的效果，macOS 上要么改 /etc/motd 并通过 SSH 登录，要么在 shell 启动文件里自己加显示逻辑。那个喜闻乐见的佛祖保佑就是这么做的.

cat /etc/os-release输出当前机器版本信息. MacOS使用命令: 

```
sw_vers     # 简略信息
system_profiler SPSoftwareDataType # 详细信息
```

<figure style="text-align: center;">
<img src="/assets/img/linux6.png" alt="" width="500">
<figcaption>MacOS 查看版本信息</figcaption>
</figure>

Linux中/proc/cpuinfo保存CPU相关信息, /proc/meminfo保存内存相关信息. 在 macOS 上找不到 /proc 目录，因为那是 Linux 内核提供的 procfs（proc 文件系统），用来以文件形式暴露内核和进程信息。macOS 基于 BSD/Darwin 内核，没有挂载 /proc，所以：

| **Linux /proc 内容** |      **macOS 替代方法**      |
|:--------------------:|:----------------------------:|
|     /proc/cpuinfo    |          sysctl -a          |
|     /proc/meminfo    |        vm_stat 或 top        |
| /proc/[pid] 进程信息 | ps -p <PID> -o pid,ppid,comm |
|     /proc/mounts     |             mount            |
|     /proc/uptime     |            uptime            |
|     /proc/version    |           uname -a           |

> ChatGPT说是**`sysctl -a**, 输入显示**bquote>**, 查了一下“backquote continuation” —— 它在等你输入反引号的结束符。Ctrl + C退出.
> sysctl -a | grep machdep.cpu  ## 查CPU信息
> sysctl hw.memsize  ## 查内存信息

<figure style="text-align: center;">
<img src="/assets/img/linux7.png" alt="" width="500">
<figcaption>MacOS命令: sysctl -a </figcaption>
</figure>

---

## Linux 用户权限

前面说了Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。所以为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。在 Linux 中通常使用以下两个命令来修改文件或目录的所属用户与权限：

- chown (change owner) ： 修改所属用户与组。
- chmod (change mode) ： 修改用户的权限。

<figure style="text-align: center;">
<img src="/assets/img/linux8.png" alt="" width="500">
<figcaption>chown 授权用户，chmod 为用户设置可以开门的权限</figcaption>
</figure>

### 文件的属性以及文件属主和属组


```
ls -l  ## 或ll
```

<figure style="text-align: center;">
<img src="/assets/img/linux9.png" alt="" width="500">
<figcaption>ls -l</figcaption>
</figure>

实例中，bin 文件的第一个属性用 **d** 表示。d 在 Linux 中代表该文件是一个目录文件。
> 在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。
> - d: 目录
> - -: 文件
> - l: 链接文档(link file)
> - b: 装置文件里面的可供储存的接口设备(可随机存取装置)
> - c: 装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)

接下来的字符中，以三个为一组，且均为 rwx 的三个参数的组合。其中， r 代表可读(read)、 w 代表可写(write)、 x 代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 - 而已。

<figure style="text-align: center;">
<img src="/assets/img/linux10.png" alt="" width="500">
<figcaption>文件属性1</figcaption>
</figure>

每个文件的属性由左边第一部分的 10 个字符来确定（如下图）。

<figure style="text-align: center;">
<img src="/assets/img/linux11.png" alt="" width="500">
<figcaption>文件属性2</figcaption>
</figure>

从左至右用 0-9 这些数字来表示。
第 0 位确定文件类型，第 1-3 位确定属主（该文件的所有者）拥有该文件的权限。
第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。
其中，第 1、4、7 位表示读权限，如果用 r 字符表示，则有读权限，如果用 - 字符表示，则没有读权限；
第 2、5、8 位表示写权限，如果用 w 字符表示，则有写权限，如果用 - 字符表示没有写权限；第 3、6、9 位表示可执行权限，如果用 x 字符表示，则有执行权限，如果用 - 字符表示，则没有执行权限。

总结: 对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。
同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。
文件所有者以外的用户又可以分为文件所属组的同组用户和其他用户。
因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。对于 root 用户来说，一般情况下，文件的权限对其不起作用。**(cd ~ 进入/root目录)**

### 更改文件属性

**chgrp：更改文件属组**

```
chgrp [-R] 属组名 文件名
```

-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上 -R 的参数，那么该目录下的所有文件的属组都会更改。

**chown：更改文件所有者（owner），也可以同时更改文件所属组**

```
chown [–R] 所有者 文件名
chown [-R] 所有者:属组名 文件名
```

**chmod：更改文件9个属性**

Linux文件属性有两种设置方法，一种是数字，一种是符号。
Linux 文件的基本权限就有九个，分别是 owner/group/others(拥有者/组/其他) 三种身份各有自己的 read/write/execute 权限。
先复习一下刚刚上面提到的数据：文件的权限字符为： -rwxrwxrwx ， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：

- r:4
- w:2
- x:1

每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： -rwxrwx--- 分数则是：

- owner = rwx = 4+2+1 = 7
- group = rwx = 4+2+1 = 7
- others= --- = 0+0+0 = 0

所以等一下我们设定权限的变更时，该文件的权限数字就是 770。变更权限的指令 chmod 的语法是这样的：

```
chmod [-R] xyz 文件或目录
```

- xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。
- -R : 进行递归(recursive)的持续变更，以及连同次目录下的所有文件都会变更

还可以用符号类型改变文件权限, 九个权限分别是：

- user：用户
- group：组
- others：其他

使用 u, g, o 来代表三种身份的权限。此外， a 则代表 all，即全部的身份。读写的权限可以写成 r, w, x，也就是可以使用下表的方式来看：

| chmod | u<br>g<br>o<br>a | +(加入)<br>-(除去)<br>=(设定) | r<br>w<br>x | 文件或目录 |

如果我们需要将文件权限设置为 **-rwxr-xr--** ，可以使用以下命令:

```
chmod u=rwx,g=rx,o=r [文件名]
```

如果是要将权限去掉而不改变其他已存在的权限呢？例如要拿掉全部人的可执行权限，则：

```
chmod a-x [文件名]
```

---

## Linux 文件与目录管理

Linux 的目录结构为树状结构，最顶级的目录为根目录 /。
其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。首先介绍绝对路径与相对路径。
- 绝对路径：由根目录 / 写起，例如： /usr/share/doc 这个目录。
- 相对路径：不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成： cd ../man 这就是相对路径的写法。

几个常见的处理目录的命令：
- ls（list files）: 列出目录及文件名
- cd（change directory）：切换目录
- pwd（print work directory）：显示目前的目录
- mkdir（make directory）：创建一个新的目录
- rmdir（remove directory）：删除一个空的目录
- cp（copy file）: 复制文件或目录
- rm（remove）: 删除文件或目录
- mv（move file）: 移动文件与目录，或修改文件与目录的名称

使用 man [命令] 来查看各个命令的使用文档，如 ：man cp。

### ls

```
[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称  ## 可选参数
[root@www ~]# ls [--color={never,auto,always}] 目录名称  ## 控制 ls 输出时是否使用颜色高亮文件类型
[root@www ~]# ls [-T] 目录名称  ## 时间. linux命令: ls [--full-time] 目录名称
```

**-aAdfFhilnrRSt**
> -a 显示所有文件（包括隐藏文件）
> -A 类似 -a，但不显示 . 和 ..
> -d 只显示目录本身，不显示目录内容
> -f 不排序，直接输出结果
> -F 在文件名后加标识符（如 / 表示目录，* 表示可执行文件）
> -h 人类可读的文件大小（KB、MB、GB）
> -i 显示 inode 号码
> -l 长列表格式显示
> -n 用数字显示用户和组 ID（而不是名字）
> -r 反向排序
> -R 递归列出子目录
> -S 按文件大小排序
> -t 按时间排序

<figure style="text-align: center;">
<img src="/assets/img/linux12.png" alt="" width="500">
<figcaption>ls可选参数</figcaption>
</figure>

**--color**

> never 从不显示颜色
> auto 默认自动显示（通常是终端才显示颜色，重定向到文件时不显示）
> always 始终显示颜色

<figure style="text-align: center;">
<img src="/assets/img/linux12.png" alt="" width="500">
<figcaption>强制显示颜色</figcaption>
</figure>

**-T**
在长格式 (-l) 显示时，输出完整的时间信息（包含秒和时区），而不是精确到分钟。

<figure style="text-align: center;">
<img src="/assets/img/linux13.png" alt="" width="500">
<figcaption>精确到秒的时间</figcaption>
</figure>

选项与参数：
- -a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)
- -d ：仅列出目录本身，而不是列出目录内的文件数据(常用)
- -l ：长数据串列出，包含文件的属性与权限等等数据；(常用)

如:将目录下的所有文件列出来(含属性与隐藏档)

```
[root@www ~]# ls -al ~
```

### cd

很简单, 只强调一个cd ~是回到/root

### pwd

显示目前所在目录

```
pwd [-P]  ## 参数-P: 显示出确实的路径，而非使用链接 (link) 路径。
```

链接档: 类似 Windows 的快捷方式，但比快捷方式底层得多，操作系统会把它当作目标文件来处理。访问符号链接时，系统会自动跳转到它指向的目标路径。如果目标被删除，链接就会“失效”，变成“悬空链接”。

创建符号连接:

```
ln -s [目标文件] [链接文件]
```

> Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。默认情况下，ln 命令产生硬链接。
硬连接
硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。
硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。
软连接
另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。
简单通俗的说：
硬链接是同一个文件的同一个索引点的不同名字，删除其中几个不受影响。
软连接类似于快捷方式，被链接文件丢失，导致链接失效，但链接任然存在

### mkdir

```
mkdir [-mp] 目录名称
```

- -m ：配置文件的权限. 直接配置，不需要看默认权限 (umask) 制约. 如果没有加上 -m 来强制配置属性，系统会使用默认属性。
- -p ：直接将所需要的目录(包含上一级目录)递归创建起来

```
mkdir test1/test2/test3/test4
mkdir: cannot create directory `test1/test2/test3/test4': 
No such file or directory       <== 没办法直接创建此目录

mkdir -p test1/test2/test3/test4 ## 正确语法
```

### rmdir

```
rmdir [-p] 目录名称  ## -p ：从该目录起，一次删除多级空目录
```

rmdir 仅能删除空的目录，删除非空目录使用 rm 命令。

### rm

```
rm [-fir] 文件或目录
```

- -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；
- -i ：互动模式，在删除前会询问使用者是否动作
- -r ：递归删除,最常用在目录的删除. 这是非常危险的选项

### mv

移动文件与目录，或修改名称

```
[root@www ~]# mv [-fiu] source destination
[root@www ~]# mv [options] source1 source2 source3 .... directory
```

- -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；
- -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖
- -u ：若目标文件已经存在，且 source 比较新，才会升级 (update)

如果将文件a更名为b: mv a b



### cp

```
[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)
[root@www ~]# cp [options] source1 source2 source3 .... directory
```

- -a：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)
- -d：若来源档为链接档的属性(link file)，则复制链接档属性而非文件本身；
- -f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；
- -i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)
- -l：进行硬式链接(hard link)的链接档创建，而非复制文件本身；
- -p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；
- -r：递归持续复制，用於目录的复制行为；(常用)
- -s：复制成为符号链接档 (symbolic link)，亦即『捷径』文件；
- -u：若 destination 比 source 旧才升级 destination ！

## Linux 文件内容查看

- cat  由第一行开始显示文件内容
- tac  从最后一行开始显示
- nl   显示的时候，顺道输出行号
- more 一页一页的显示文件内容
- less 与 more 类似，但是比 more 更好的是可以往前翻页
- head 只看头几行
- tail 只看尾巴几行

### cat/tac 

```
cat/tac [-AbEnTv]
```

- -A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；
- -b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！
- -E ：将结尾的断行字节 $ 显示出来；
- -n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；
- -T ：将 [tab] 按键以 ^I 显示出来；
- -v ：列出一些看不出来的特殊字符

### nl

```
nl [-bnw] 文件
```

- -b ：指定行号指定的方式，主要有两种：
-ba ：表示不论是否为空行，也同样列出行号(类似 cat -n)；
-bt ：如果有空行，空的那一行不要列出行号(默认值)；
- -n ：列出行号表示的方法，主要有三种：
-nln ：行号在荧幕的最左方显示；
-nrn ：行号在自己栏位的最右方显示，且不加 0 ；
-nrz ：行号在自己栏位的最右方显示，且加 0 ；
- -w ：行号栏位的占用的位数

<figure style="text-align: center;">
<img src="/assets/img/linux15.png" alt="" width="500">
<figcaption>nl</figcaption>
</figure>

### more

一页一页翻动. 按键:

- 空白 (space)：代表向下翻一页；
- Enter：代表向下翻『一行』；
- /字串：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；
- :f：立刻显示出档名以及目前显示的行数；
- q：代表立刻离开 more ，不再显示该文件内容。
- b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。

### less

- 空白：向下翻动一页；
- [pagedown]：向下翻动一页；
- [pageup]  ：向上翻动一页；
- /字串     ：向下搜寻『字串』的功能；
- ?字串     ：向上搜寻『字串』的功能；
- n         ：重复前一个搜寻 (与 / 或 ? 有关！)
- N         ：反向的重复前一个搜寻 (与 / 或 ? 有关！)
- q         ：离开 less 这个程序；

### head/tail

```
head [-n number] 文件  ## -n 后面接数字，代表显示几行的意思. 默认的情况中，显示前面 10 行 
```

```
tail [-n number] 文件  ## -n 后面接数字，代表显示几行的意思. 
tail -f 文件  ## 监控: 显示文件末尾的 N 行后，不会退出，而是持续监控文件，如果文件有新的内容追加，就立刻把新内容显示出来。
直到你按 Ctrl + C 才结束监控。
```

---

## Linux 用户和用户组管理

### Linux系统用户账号的管理

用户账号的管理工作主要涉及到用户账号的添加、修改和删除。
添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。刚添加的账号是被锁定的，无法使用。

**添加新的用户账号**

```
useradd 选项 用户名
```

- -c comment 指定一段注释性描述。
- -d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。
- -g 用户组 指定用户所属的用户组。
- -G 用户组，用户组 指定用户所属的附加组。
- -s Shell文件 指定用户的登录Shell。
- -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。

如 useradd –d  /home/sam -m sam: 创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录 /home/sam（/home为默认的用户主目录所在的父目录）。

如 useradd -s /bin/sh -g group –G adm,root gem: 新建了一个用户gem，该用户的登录Shell是 /bin/sh，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。
这里可能新建组：#groupadd group及groupadd adm
增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。

Linux提供了集成的系统管理工具userconf，它可以用来对用户账号进行统一管理。

**删除帐号**
如果一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。
删除一个已有的用户账号使用userdel命令，其格式如下：

```
userdel 选项 用户名
```

常用的选项是 -r，它的作用是把用户的主目录一起删除。

如 userdel -r sam: 此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。

**修改帐号**
修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。
修改已有用户的信息使用usermod命令，其格式如下：

```
usermod 选项 用户名
```

常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。
另外，有些系统可以使用选项：-l 新用户名
这个选项指定一个新的账号，即将原来的用户名改为新的用户名。
例如 usermod -s /bin/ksh -d /home/z –g developer sam. 此命令将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。

**用户口令的管理**
用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。
指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：

```
passwd 选项 用户名
```

可使用的选项：
- -l 锁定口令，即禁用账号。
- -u 口令解锁。
- -d 使账号无口令。
- -f 强迫用户下次登录时修改口令。
如果默认用户名，则修改当前用户的口令。
例如，假设当前用户是sam，则下面的命令修改该用户自己的口令：

```
$ passwd 
Old password:****** 
New password:******* 
Re-enter new password:*******
```

如果是超级用户，可以用下列形式指定任何用户的口令：

```
# passwd sam 
New password:******* 
Re-enter new password:*******
```

普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。
为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。

为用户指定空口令时，执行下列形式的命令：

```
# passwd -d sam
```

此命令将用户 sam 的口令删除，这样用户 sam 下一次登录时，系统就不再允许该用户登录了。
passwd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录，例如：

```
# passwd -l sam
```

### Linux系统用户组的管理

每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。
用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新

**增加一个新的用户组：**

```
groupadd 选项 用户组
```

可以使用的选项有：
- -g GID 指定新用户组的组标识号（GID）。
- -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。
如 groupadd group1: 向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。
如 groupadd -g 101 group2: 此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。

**删除一个已有的用户组：**

```
groupdel 用户组
```
如 groupdel group1: 从系统中删除组group1。

**修改用户组的属性：**

```
groupmod 选项 用户组
```

- -g GID 为用户组指定新的组标识号。
- -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。
- -n 新用户组 将用户组的名字改为新名字
如 groupmod -g 102 group2: 将组group2的组标识号修改为102。
如 groupmod –g 10000 -n group3 group2: 将组group2的标识号改为10000，组名修改为group3。

**用户组切换**
如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。
用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。

```
$ newgrp root
```

这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。


### 与用户账号有关的系统文件

Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。
用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。
每个用户账号都拥有一个唯一的用户名和各自的口令。
用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。
实现用户账号的管理，要完成的工作主要有如下几个方面：
- 用户账号的添加、删除与修改。
- 用户口令的管理。
- 用户组的管理。

完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。
与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等。

**/etc/passwd文件**
是用户管理工作涉及的最重要的一个文件。
Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。
这个文件对所有用户都是可读的。它的内容类似下面的例子：

<figure style="text-align: center;">
<img src="/assets/img/linux16.png" alt="" width="500">
<figcaption>/etc/passwd文件</figcaption>
</figure>

/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：

用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell

> "用户名"是代表用户账号的字符串。
通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。
为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。
> “口令”一些系统中，存放着加密后的用户口令字。
虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。
> “用户标识号”是一个整数，系统内部用它来标识用户。
一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。
通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。
> “组标识号”字段记录的是用户所属的用户组。
它对应着/etc/group文件中的一条记录。
> “注释性描述”字段记录着用户的一些个人情况。
例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。
> “主目录”，也就是用户的起始工作目录。
它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。
> 用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。
Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。
系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。
用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。
利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。
> 系统中有一类用户称为伪用户（pseudo users）。
这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。
常见的伪用户如下所示：

| 伪 用 户 | 含 义                    |
|----------|--------------------------|
| bin      | 拥有可执行的用户命令文件 |
| sys      | 拥有系统文件             |
| adm      | 拥有帐户文件             |
| uucp     | UUCP使用                 |
| lp       | lp或lpd子系统使用        |
| nobody   | NFS使用                  |


**/etc/shadow文件**

除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。
由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。 有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生. 它的文件格式与/etc/passwd类似，由若干个字段组成，字段之间用":"隔开。这些字段是：

登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志

> "登录名"是与/etc/passwd文件中的登录名相一致的用户账号
> "口令"字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。
> "最后一次修改时间"表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。
> "最小时间间隔"指的是两次修改口令之间所需的最小天数。
> "最大时间间隔"指的是口令保持有效的最大天数。
> "警告时间"字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。
> "不活动时间"表示的是用户没有登录活动但账号仍能保持有效的最大天数。
> "失效时间"字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。

MacOS命令:

```
sudo dscl . -read /Users/用户名
```
会看到类似：Password: ********. 真正的密码是加密存储的，系统不直接暴露出来。


**/etc/group文件**

用户组的所有信息都存放在/etc/group文件中。
将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。
每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。
当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。
用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。
用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有：

组名:口令:组标识号:组内用户列表

> "组名"是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。
> "口令"字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。
> "组标识号"与用户标识号类似，也是一个整数，被系统内部用来标识组。
> "组内用户列表"是属于这个组的所有用户的列表，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。

<figure style="text-align: center;">
<img src="/assets/img/linux17.png" alt="" width="500">
<figcaption>/etc/group文件</figcaption>
</figure>

**添加批量用户**
添加和删除用户对每位Linux系统管理员都是轻而易举的事，比较棘手的是如果要添加几十个、上百个甚至上千个用户时，我们不太可能还使用useradd一个一个地添加，必然要找一种简便的创建大量用户的方法。Linux系统提供了创建大量用户的工具，可以立即创建大量用户.

Linux要编写用户名密码txt, MacOS一般用sudo命令.



---

## Linux 磁盘管理

Linux 磁盘管理常用三个命令为 df、du 和 fdisk。
- df（英文全称：disk free）：列出文件系统的整体磁盘使用量
- du（英文全称：disk used）：检查磁盘空间使用量
- fdisk：用于磁盘分区








---

## vi/vim

所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。
但是目前我们使用比较多的是 vim 编辑器。

说实话第一次用的时候感觉挺反人类的. 之前的文章写过几条常用命令, 其他要用的时候查一下就行.

稍微补充一点，vim中可以实现文档之间的跳转:

在命令模式下，光标停留在某个文档的路径上。（此时文档不能被修改过）
- gf : 跳转到路径指示的文档中
- ctrl + o ： 返回原文档



---

## yum

就是一个包安装命令.
yum（ Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器。
基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。
yum 提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。

```
yum [options] [command] [package ...]
```

看了一下yum --version, 我这个系统里面没装. 应该是之前的linux里装的.


---

## apt

apt（Advanced Packaging Tool）是一个在 Debian 和 Ubuntu 中的 Shell 前端软件包管理器。
apt 命令提供了查找、安装、升级、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。
apt 命令执行需要超级管理员权限(root), 也就是sudo apt ...


```
apt [options] [command] [package ...]
```