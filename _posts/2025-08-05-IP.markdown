---
layout: post
title:  IP
date:   2025-08-05
description: You’ll find this post in your `_posts` directory. Go ahead and edit it and re-build the site to see your changes. # Add post description (optional)
img: nat.png # Add image post (optional)
tags: [Blog, Computer Network]
author: # Add name author (optional)
---
# 本讲内容

NAT(NPAT): 当局域网内的一台电脑想要与互联网中的电脑通信时, 因为局域网内的电脑只有私网ip(不能出现在互联网上), 所以上层路由器将其ip改为公网ip, 同时重新为该连接随机分配一个端口及其与地址的映射关系. 起转发作用.

端口映射: 上面所说连接一旦断开, 中介端口就不再使用. 所以内网电脑只能向外访问, 但是不能接受数据, 因为路由器不会处理. 所以需要在上面基础上分配一个永久的端口, 这样就可以一直连接通信了.

内网穿透: 两个局域网中的两台电脑要连接, 需要一个中介服务器. 中介服务器的带宽会影响信息通信速度. 比起来端口映射就相当于直连.

p2p和打洞: 


NAT打洞: 两个处于不同nat网关的电脑连接, 

---

## NAT

### NAT原理
NAT 全称 Network Address Translation，即网络地址转换，可以理解为公网地址和内网地址的映射规则。从名字看很好理解，就是对数据包的IP地址进行修改；
一个常见的网络数据从网络流量角度来看可以分为五部分：源IP、源端口、协议、目的IP、目的端口；这就是常说的五元组，如果不算协议的话就是四元组，IP通信能正常运行的关键就是这五元组。

> SrcAddr; SrcPort; Protocol; DestAddt; DestPort

NAT 通常是个路由器，且最早是作为 iPv4 地址短缺的一种解决方案而流行起来的。由于公网IPv4地址早已经耗尽，以现在的大众上网的终端数量来看IP地址已经不够用，但现在看起来好像也没受什么影响，这个就得益于一种NAT技术--NAPT也称为PAT，即端口转换。NAPT是一种IP地址复用技术，由于大多数网络流量都基于TCP和UDP，这种传输层协议的寻址使用端口，端口号为1~65535，端口号是充裕的，“复用IP地址”+“改写端口号”是PAT技术的理论基础。

以常见的基于地址和端口转换的 NAPT 为例。如下图所示，假设有台路由器的公网地址为 172.217.194.113 ；此时内网有台地址为 10.0.0.1 的设备想要访问公网服务器，则：

<figure style="text-align: center;">
<img src="/assets/img/nat1.png" alt="NAPT" width="500">
<figcaption>NAPT</figcaption>
</figure>

1. 10.0.0.1 这台设备上端口为 3000 的程序发出源地址为 10.0.0.1:3000 的 IP 数据包。
2. IP 数据包经过路由器时，路由器对其源地址进行查表；如果源地址不在表中，便会自动分配一个端口号给它，图中对应的端口号就是 8080；同时其内网 IP 也会被替换为公网 IP。
3. IP 数据包经过路由器后，源地址变为 172.217.194.113:8080 ，而目标地址不变。

于是 10.0.0.1 这台设备便可以访问公网服务器了。同理，当公网服务器回包时，路由器会进行反向查表，将请求结果转发给 10.0.0.1 这台设备。

设想两台内网电脑复用一个公网地址访问server的80端口：

```
PC1:IP1-port1-tcp-Server-80
PC2:IP2-port2-tcp-Server-80
```

由于内网地址无法在公网路由，NAT设备将内网IP转换为公网IP，并配合修改端口号以达成复用公网IP目的：

```
PC1:IP-portA-tcp-Server-80
PC2:IP-portB-tcp-Server-80
```

此时就能使用portA和B对回包数据进行区分，并分别转发给内网的PC1和PC2；
但是PAT也也引发了一些问题，PAT打破了IP地址的点对点可达性，导致处于NAT后的终端只能主动向外发起网络通信，无法由外向内主动访问。

### NAT分类

从PAT的原理看，PAT只能在通信一端应用，双方均处于NAT后面的话无法通信；但如果再深入研究还是能发现一些解决方案。根据转换策略不同，PAT还有更细的分类，常见的分类如下图：对称型，完全锥型，ip限制型锥型，端口限制型锥型

<figure style="text-align: center;">
<img src="/assets/img/nat3.png" alt="分类" width="500">
<figcaption>分类</figcaption>
</figure>

图中描述了四种分类：FullCone、Restricted、Port-Restricted、Symmetric四种；有时候也会叫做NAT1/2/3/4。

从发起方的 NAT 设备角度来看，为了不影响通信，五元组中协议、目的IP、目的端口肯定无法更改，能够修改的只有源IP和源端口；
图中分类方式基于两方面，第一.回包的安全限制；第二.转换后端口受那些因素影响；

- NAT1/FullCone：转换端口仅和源IP及源端口有关，安全限制基本没有，只要是发往转换后IP和端口的报文均转发给内网。
- NAT2/Restricted：转换端口仅和源IP及源端口有关，限制回包地址为发包的目的地址，回包源端口不限制。
- NAT3/Port-Restricted：转换端口仅和源IP及源端口有关，限制回包地址为发包的目的地址，回包源端口也必须为发包的目的端口。
- NAT4/Symmetric：转换端口与源IP、源端口、目的IP、目的端口即四元组均有关，限制回包地址为发包的目的地址，回包源端口也必须为发包的目的端口。

假定：
公网server1：ip是1.1.1.1，监听端口是1111
公网server2：ip是2.2.2.2，监听端口是2222
NAT网关：ip是3.3.3.3
NAT内部需要穿透的电脑A：内网ip是：192.168.0.2
此刻，A（192.168.0.2:100）已经通过NAT网关（3.3.3.3:200）和server1（1.1.1.1:1111）建立了链接

完全锥型：如果在NAT网关已经建立了一个NAT映射，那么任何外网的机器都可以通过这个映射来访问内网的电脑，例如此刻server2如果想和A建立通信，那么只需要往3.3.3.3:200发送数据包，NAT网关就会接收数据包并将其转发到内部的192.168.0.2:100上。
如果A主动使用同样的端口去和不同的服务器或和相同的服务器，不同的端口建立连接时，NAT的映射也会使用同样的端口，例如A若是想用100端口和server2建立连接，NAT网关仍然会把3.3.3.3:200映射到192.168.0.2:100上，而不是重新选择一个端口映射到100.

ip限制型锥型：如果在NAT网关已经建立了一个NAT映射，那么只有与其建立映射的ip才能通过NAT访问内网的电脑。例如此刻如果server1想通过1112这个端口和A再建立一个连接，那么只需要往3.3.3.3:200发送数据，NAT会正常的将其转发到192.168.0.2:100，但是如果此刻server2想和A建立连接，因为server2在此前并未和A建立连接，所以如果server2给3.3.3.3:200发送数据的话，NAT网关会将来自server2的数据包直接丢弃。

端口限制型锥型：这个类型虽然叫端口限制型，但其实限制的不只是端口，ip也同样限制，可以理解为在ip限制型锥型的基础上，再进行端口的限制，也就是说现在不只对ip有需求，连端口都有需求，如果按照上面的例子，此刻如果server还想通过1112端口和A建立连接就不行了，因为限制了端口，只有从1.1.1.1:1111发来的数据NAT网关才会处理。

对称型NAT：可以看出来，上述的三个类型限制是越来越严格，按照这个思路，对称型NAT的限制会更加严格。首先，对称型NAT和端口限制型锥型是一样的，即对ip和端口都有限制，只有和其建立连接的ip和端口向其发送数据才不会被丢弃。


我们上述说了，锥型网络的特征是如果A使用了100端口和外网的另一台服务器通信，那么NAT网关和其绑定的端口依然是200，一个端口和外面的诸多服务器进行通信，这也正是锥型这种叫法的来源，但是对称型NAT并不是这样。
对称型NAT在A主动使用相同的端口去和不同服务器或和相同的服务器不同的端口建立连接时，NAT网关会给其重新分配一个端口。
例如，我们在最开始的时候说，A（192.168.0.2:100）已经通过NAT网关（3.3.3.3:200）和server1（1.1.1.1:1111）建立了链接，此时如果A（192.168.0.2:100）想和server2（2.2.2.2:2222）建立连接的话，如果使用锥型NAT，那么这个NAT网关会继续使用之前建立的NAT映射（3.3.3.3:200映射到192.168.0.2:100），而如果现在使用对称型NAT的话，NAT网关会再随机分配一个端口（例如300），建立一个映射（3.3.3.3:300映射到192.168.0.2:100），注意，此时NAT网关中存在两条映射规则，分别是：3.3.3.3:200映射到192.168.0.2:100和3.3.3.3:300映射到192.168.0.2:100，也就是说，此刻server1是和3.3.3.3:200进行通信，server2是和3.3.3.3:300进行通信，但是实际上，经过NAT网关的转发后，他们的数据包，最终都被192.168.0.2:100接收。

需要注意的是，内网电脑A始终都是通过100这个端口和外界通信的，而这两条映射规则则是NAT网关建立的，所以电脑A并不知道200和300这个端口，它始终认为自己就是通过100这个端口和外界通信，在外界的两个server来看，它们也并不知道自己是在和主机A通信，它们认为它们在和NAT网关（3.3.3.3）的不同端口进行通信。

---

## 内网穿透

内网穿透，也即 NAT 穿透，进行 NAT 穿透是为了使具有某一个特定源 IP 地址和源端口号的数据包不被 NAT 设备屏蔽而正确路由到内网主机。实现技术有以下几种:

- NAT打洞
- 使用公网服务器做中转转发（如 frp、ngrok）
- VPN / ZeroTier 等虚拟网络技术
- 路由器做 端口映射（Port Forwarding）

### NAT 打洞

所谓NAT打洞就是在通信双方都处于NAT后面时候，使用某种方式使得通信双方可以正常端到端通信。
基于TCP的NAT打洞基本放弃，TCP协议本是有状态的，NAT设备一般只允许outbound发起syn，所以 NAT 打洞技术基本都是基于UDP协议的。这里先说一下结论，在仅能控制终端无法控制NAT设备，通信双方都实施PAT的情况下，能够实现UDP打洞的关键为：**任一端NAT会话中的内容可以被预测**

STUN协议是一个专门用于NAT打洞的协议，但是打洞两侧的NAT类型是有要求的，如下表：

<figure style="text-align: center;">
<img src="/assets/img/nat4.png" alt="STUN" width="500">
<figcaption>STUN</figcaption>
</figure>

这里不讨论STUN协议的细节和应用，只讨论其原理。

- NAT1:对回包没有安全限制，所以其NAT会话中只包含转换后的源IP和源端口，且转换后端口仅和内网源IP+源端口有关；
- NAT2：回包仅限制IP，所以其NAT会话中只包含转换后的源IP、源端口、目的IP，且转换后端口仅和内网源IP+源端口有关；
- NAT3：回包仅限制IP和端口，所以其NAT会话中只包含转换后的源IP、源端口、目的IP、目的端口，且转换后端口仅和内网源IP+源端口有关；
- NAT4：回包仅限制IP和端口，所以其NAT会话中只包含转换后的源IP、源端口、目的IP、目的端口，转换后端口仅和上述四元组均有关；


<figure style="text-align: center;">
<img src="/assets/img/nat5.png" alt="情景" width="500">
<figcaption>情景</figcaption>
</figure>


设想这样一个场景，user1和user2分别处于两个NAT后面，NAT设备出接口有一个公网地址，server为有公网地址的第三方用于预测打洞时NAT会话。

- USER1为NAT1场景：user1 使用 addr1 和 port1 访问server，从server处获知转换后addr 和 port，user2无论是什么种类的NAT，直接访问user1 转换后的addr和port即可通信。

- USER1为NAT2，USER2不用区分种类，user1使用addr1 和port 1访问server获取转化后地址address和端口port，user2 访问server 获取user2公网地址addr2，这时候user1再使用addr 1 port 1 访问目的地址为addr2的任意端口，创建NAT会话，然后user2再访问address/port即可完成通信。

- 双方均为NAT3情况，user1使用addr1/port1访问server得到转换后addrA/portA，user2使用addr2/port2访问server获知转换后addrB/portB，user1和user2先后使用先前访问server的端口访问对方转换后的地址即可完成通信。

- 其余情况由于转换后端口受影响的因素过多，导致无法准确预测，也就无法实现NAT打洞。







假设存在两台设备 A 和 B，它们分别位于各自的 NAT_A 和 NAT_B 之后。此时 A 第一次尝试和 B 建立点对点连接，向 NAT_B 发送数据包；然而 NAT_B 经过查表发现，之前并没有 A 和 B 的映射（即 A 的请求无法被转发到 B），于是来自 A 的数据包就会被丢弃。

为了能绕过 NAT 的限制，我们需要借助一台公网上的服务器 S 做地址转发。如下图所示：

<figure style="text-align: center;">
<img src="/assets/img/nat2.png" alt="打洞" width="500">
<figcaption>打洞</figcaption>
</figure>

1. A 与 S 建立连接（Session A-S），向 S 注册自己的内网地址 10.0.0.1:4321 ；S 会同时记录 A 在公网的地址 155.99.25.11:62000 。B 与 S 建立连接（Session B-S），向 S 注册自己的内网地址 10.1.1.3:4321 ；S 会同时记录 B 在公网的地址 138.76.29.7:31000 。
2. A 向 S 发送请求，获取 B 的地址（Request Connection to B）；S 会同时把 A 的地址转发给 B（Forward A’s Endpoints to B）。然后 A 和 B 都开始尝试相互向对方发送数据包。
3. 当 A 向 B 第一次发送数据包时（Send to B at）会在 NAT_A 中产生映射 (10.0.0.1:4321, 138.76.29.7:31000) ；此时 NAT_B 并没有 A 和 B 的映射记录，数据包仍然会被丢弃。
4. 当 B 向 A 第一次发送数据包时（Send to A at）会在 NAT_B 中产生映射 (10.1.1.3:4321, 155.99.25.11:62000) ；因为之前 NAT_A 已经创建了 A 和 B 的映射，所以 B 请求成功。
5. 当 A 向 B 第二次发送数据包时，因为 NAT_B 也有了 A 和 B 的映射记录，所以 A 也请求成功。于是打洞完成，A 和 B 可以直接建立点对点连接（Session A-B）。

假设存在两台设备 A1 和 A2，它们同时位于 NAT_A 之后，且它们并不知晓各自的地址。当 A1 和 A2 通过上述步骤建立连接后，它们会发现双方都在同一内网，而所有数据包仍然需要通过 NAT_A 转发是没有必要的，直接使用内网地址建立连接显然更快。


### SSH端口转发

ssh端口转发分为本地端口转发(-L)，远程端口转发(-R)和动态端口转发几种

本地端口转发和远程端口转发都比较好理解，仅作下记录，给个命令，方便后面查询。

1. 本地端口转发

用来把远程的端口服务映射到本地localhost的端口服务。一般用于远程机器上有一个服务，但是有防火墙无法直接访问，通过ssh映射到本地越过防火墙进行访问。

```
ssh -L 主机A:端口X:主机C:端口Z username@hostname -N
# 简单理解为：将对A:X的访问转变成对C:Z的访问
```

-L 表示本地端口转发。

主机A即为本地机器，可忽略。

需要注意的是，主机C可以是任何能够被主机B识别到的设备(比如说主机C所在内网的其它设备)，也可以是主机B自身。
-N 表示仅做端口映射，但并不登入主机C

2. 远程端口转发

用来把远程主机的端口服务映射为本地服务。应用场景比如: 微信小程序服务端、webhook开发等。

```
ssh -R 主机B端口Y:主机C:主机C端口Z username@hostname
# 简单理解为：将对B:Y的访问转变成对C:Z的访问
```

-L 表示远程端口转发

主机B为远程主机

需要注意的是, 主机C可以是任何能够被主机A识别到的设备(比如说主机C所在内网的其它设备)，也可以是主机A自身。

3. 动态端口转发

动态端口转发可以把本地主机A上运行的SSH客户端转变成一个SOCKS代理服务器；实际上它是一种特殊的本地端口转发，或者说叫它「动态本地端口转发」更科学。这个动态，就动在这种转发不规定目标地址（主机C）和目标端口（端口Z），而是去读取应用发起的请求，从请求中获取目标信息。

```
ssh -D 本地网卡地址:本地端口 username@hostname -N
```

- -D 表示动态转发
- 本地网卡地址 是本地主机，可忽略
- 本地端口 是 SOCKS5 代理端口
- -N 表示这个 SSH 连接只进行端口转发，不登录远程 Shell，不能执行远程命令，只能充当隧道。

举例来说，如果本地端口是2121，那么动态转发的命令就是下面这样。

```
ssh -D 2121 username@hostname -N
```

注意，这种转发采用了 SOCKS5 协议。访问外部网站时，需要把 HTTP 请求转成 SOCKS5 协议，才能把本地端口的请求转发出去。

可以在系统或应用（浏览器等）中设置一个使用SOCKS5协议、服务器为localhost、端口为X的代理，利用代理使请求走端口X。


下面是 SSH 隧道建立后的一个使用实例。

```
curl -x socks5://localhost:2121 http://www.example.com
```

上面命令中，curl 的 -x 参数指定代理服务器，即通过 SOCKS5 协议的本地2121端口，访问 http://www.example.com。

如果经常使用动态转发，可以将设置写入 SSH 客户端的用户个人配置文件（~/.ssh/config）。

```
DynamicForward tunnel-host:local-port
```

结合 ssh 的本地转发和远程转发，就可以成功在外网环境下，通过外网的中间服务器和内网的openwrt服务访问家里的所有内网服务。

之所以没有使用这种方式是因为，这种端口映射的方案，最终访问的是本地的端口，并不能做到内外俱为一体的效果，而且在移动端设备上似乎也没有比较好的免费客户端来满足需求。


### ZeroTier